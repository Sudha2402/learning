<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        canvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
        }
    </style>

    <link rel="stylesheet" href="/allPageCommonStyle.css">

</head>

<body onload="startGame()">






    <br>
    <br>

    <!-- <button onmousedown="accelerate(-0.2)" onmouseup="accelerate(0.05)">ACCELERATE</button> -->

    <!-- accelerate(-0.2) make myGamePiece.gravity = -0.2  , it means y ki value decrease hogi yahi , ye uppar jaiga , top ki taraf

    accelerate(0.05) , ye niche ki ore le jaiga myGamePiece ko.
     
    -->

    <!-- <br>
    <br>
    <br>
    <br> -->

    <!-- <button onclick="moveup()">UP</button>
<button onclick="movedown()">DOWN</button>
<button onclick="moveleft()">LEFT</button>
<button onclick="moveright()">RIGHT</button> -->

    <!-- makin above in powerful way but due to gravity it will pull in again down then on every click you will be able to move only 1 unit as it come back to ground again -->


    <!-- works but uncomment latter -->
    <!-- <div style="text-align:center;width:480px;">
        <button onmousedown="moveup()" onmouseup="clearmove()" ontouchstart="moveup()">UP</button><br><br>
        <button onmousedown="moveleft()" onmouseup="clearmove()" ontouchstart="moveleft()">LEFT</button>
        <button onmousedown="moveright()" onmouseup="clearmove()" ontouchstart="moveright()">RIGHT</button><br><br>
        <button onmousedown="movedown()" onmouseup="clearmove()" ontouchstart="movedown()">DOWN</button>
    </div> -->




    <!-- //below for new move(dir) not for adding src in initial functions -->

    <!-- works but uncomment latter -->
    <!-- <br>
    <p>for image change but ony with this button not with others controller</p>

    <div style="text-align:center;width:480px;">
        <button onmousedown="move('up')" onmouseup="clearmove()" ontouchstart="move('up')">UP</button><br><br>
        <button onmousedown="move('left')" onmouseup="clearmove()" ontouchstart="move('left')">LEFT</button>
        <button onmousedown="move('right')" onmouseup="clearmove()" ontouchstart="move('right')">RIGHT</button><br><br>
        <button onmousedown="move('down')" onmouseup="clearmove()" ontouchstart="move('down')">DOWN</button>
    </div>
 -->








    <!-- 
    <p>Use the ACCELERATE button to stay in the air</p>

    <p>How long can you stay alive?</p> -->
</body>

<script>

    var myGamePiece;



    //         Background Images

    // Add a background image to your game area by adding it as a component, and also update the background in every frame:
    var myBackground;
    // we need this to be at back of all other elements







    var myObstacles = [];//To define multiple obstacles, first declare the obstacle variable as an array.
    // we need this to be the top layer of mybackground



    //var myObstacle;//we want to add some obstacles to our game.// (step 1) we took this then for adding multiple obstacles we used array





    // Count The Score
    // There are many ways to keep the score in a game, we will show you how to write a score onto the canvas.

    var myScore;

    // First make a score component:



    var mySound; //to play the sound on moving
    var mySoundCrash; //to play sound on crash

    var mySoundAfter; //to play sound after crash





    function startGame() {

        myGamePiece = new component(30, 30, "red", 10, 120); //learned in canva//it is not default component object , it is defined by us with function and parameters it takes, general syntax of new component as per defined we have set below is new component(width, height, "color", x start coordinate, y start coordinate); //here we tried to set it at center

        //     //Change the Position
        // We use x- and y-coordinates to position components onto the game area.

        // The upper-left corner of the canvas has the coordinates (0,0)

        // Mouse over the game area below to see its x and y coordinates:





        // Many Components
        // You can put as many components as you like on the game area:

        // redGamePiece = new component(75, 75, "red", 10, 10);
        //   yellowGamePiece = new component(75, 75, "yellow", 50, 60);
        //   blueGamePiece = new component(75, 75, "blue", 10, 110);
        //   myGameArea.start();


        //Make all three components move in different directions: if you created then it should be in updateGameArea() and above update


        // then also add update in updateGameArea for each component
        //  myGameArea.clear();
        // redGamePiece.update();
        //   yellowGamePiece.update();
        //   blueGamePiece.update();





        //             How to Use Images?
        // To add images on a canvas, the getContext("2d") object has built-in image properties and methods.

        // In our game, to create the gamepiece as an image, use the component constructor, but instead of referring to a color, you must refer to the url of the image. And you must tell the constructor that this component is of type "image":

        myGamePiece = new component(30, 30, "smiley.gif", 10, 120, "image"); //here smiley.gif is not present hence it will show black color


        myGamePiece = new component(30, 30, "title logo_icon.png", 10, 120, "image"); //now it works with logo replacement


        //https://tenor.com/search/smiley-emoji-gifs

        // visit above link for gif download


        //https://stackoverflow.com/questions/4429440/html5-display-video-inside-canvas



        //https://www.remove.bg/b/remove-video-backgrounds-100-automatically-with-unscreen

        // visit above link to remove background from video

        myGamePiece = new component(30, 30, "happy-dance-nobackground.gif", 10, 120, "image");//it shows only picture format for video , learn from the given link

        /////// https://stackoverflow.com/questions/4429440/html5-display-video-inside-canvas



        // In the component constructor we test if the component is of type "image", and create an image object by using the built-in "new Image()" object constructor. When we are ready to draw the image, we use the drawImage method instead of the fillRect method:


        // myGamePiece = new component(30, 30, "emojis1.gif", 10, 120, "image");//it is with background hence not good

        myGamePiece = new component(30, 30, "emoji.gif", 10, 120, "image");
        // 
        // myGamePiece = new component(30, 30, "no-sad1 teasing.gif", 10, 120, "image");






        // Background Images
        // Add a background image to your game area by adding it as a component, and also update the background in every frame:




        // myBackground = new component(656, 270, "background nature.png", 0, 0, "image"); //ye sirf move ke liye hi capable hoga
        // myBackground.speedX = -1; se 
        //lekin loop ke liye type ko background me change kare





        // myBackground = new component(656, 270, "background nature.png", 0, 0, "background");
        // myBackground = new component(656, 270, "background nature2.png", 0, 0, "background");//good

        myBackground = new component(656, 270, "nature3.png", 0, 0, "background");//good but lies on top of cordinate images formed
        //we need to send it at most backward with tansparency so that obstacle can be seen on it



        //also update the background in every frame: 
        //so let's move to updateGameArea() 







        //Moving Background
        //myBackground.speedX = -1; in the updateGameArea()









        // Controllers on The Canvas
        // We can also draw our own buttons on the canvas, and use them as controllers:


        //  these component will be present in the screen just like mobile games , all touches(controller) present in the screen 


        //at top left

        // myUpBtn = new component(30, 30, "blue", 50, 10);//top
        // myDownBtn = new component(30, 30, "blue", 50, 70);//bottom
        // myLeftBtn = new component(30, 30, "blue", 20, 40);//left
        // myRightBtn = new component(30, 30, "blue", 80, 40);//right

        //or

        //for in top bottom center
        myUpBtn = new component(30, 30, "blue", 50, 100);
        myDownBtn = new component(30, 30, "blue", 50, 160);//bottom
        myLeftBtn = new component(30, 30, "blue", 20, 130);//left
        myRightBtn = new component(30, 30, "blue", 80, 130);//right






        //   Add a new function that figures out if a component, in this case a button, is clicked.//write it in myGameArea

        // Start by adding event listeners to check if a mouse button is clicked (mousedown and mouseup). To deal with touch screens, also add event listeners to check if the screen is clicked on (touchstart and touchend):


        //the function is this but it should be in myGameArea

        /*
        window.addEventListener('mousedown', function (e) {
              myGameArea.x = e.pageX;
              myGameArea.y = e.pageY;
            })
            window.addEventListener('mouseup', function (e) {
              myGameArea.x = false;
              myGameArea.y = false;
            })
            window.addEventListener('touchstart', function (e) {
              myGameArea.x = e.pageX;
              myGameArea.y = e.pageY;
            })
            window.addEventListener('touchend', function (e) {
              myGameArea.x = false;
              myGameArea.y = false;
            })
        
        
        */




        // Background Music
        // To add background music to your game, add a new sound object, and start playing when you start the game:

        mySound = new sound("fm-freemusic-happy-and-joyful-children(chosic.com).mp3"); //this is used to  call sound object constructor function 
        // src is


        myGameArea.canvas.addEventListener("mouseover", function () {

            mySound.play();
        });

        // mySound.play(); //uncomment it later//it is also like non stopable , so apply a condition in updateGameArea() to stop it after crash
        //play only on focus when page is scrolled upto that


        // window.addEventListener('focus', function () {


        //     // document.addEventListener("visibilitychange", function () {
        //     //we want it when page is scoll upto when it is visible or scroll to

        //     if (document.visibilityState === "visible") {
        //         mySound.play();
        //     } else {
        //         mySound.stop();
        //     }
        // });


        // best of all this let's have controller of the sound


        // window.addEventListener(
        //     "mousemove",
        //     function (event) {
        //         // Check if the mouse is within the game area
        //         if (event.clientX > 0 && event.clientX < canvas.width && event.clientY > 0
        //             && event.clientY < canvas.height) {
        //             // If the mouse is within the game area, play the sound
        //             mySound.play();


        //         } else {
        //             mySound.stop();
        //         }
        //     }
        // );









        //for horror sound
        //  https://motionarray.com/learn/royalty-free-music/horror-background-music/



        //I want this sound to play only when game is being actively payed or mouse is on that region
        //so I will add a condition in updateGameArea() to stop it after crash
        //and also add a condition to stop it when mouse is not on that region



        mySoundCrash = new sound("no-luck-too-bad-disappointing-sound-effect-112943.mp3");




        mySoundAfter = new sound("Luke-Bergs-Bliss(chosic.com).mp3"); //now it fullfills the requirement 











        //  myGamePiece.gravity = 0.05;

        //the speed it falls //gravity is property of a component //if we wanted we have set value of gravity property = 0.05 in component method but in that case all components would be affected by gravity hence  we are applying this value only in myGamePiece and that too at my startGame, and this.gravity = 0 in component method


        /* not work hence put in component only and apply condition in newPos to call hitLeft only when this component is myGamePiece
        
                    myGamePiece.hitLeft = function () {
                        if (this.x < 0) { //agar newPos myGamePiece ka jaida h
                            this.x = 0; //yaha this ke karan background image bhi move nahi karega , issleye component specify is better option in case of left and right hit stop
        
        
        
                           // this.speedX = 0;//left ko touch karne par x 0 ho jati h 
                        }
                    }
        */



        //making a score component:

        //             The syntax for writing text on a canvas element is different from drawing a rectangle. Therefore we must call the component constructor using an additional argument, telling the constructor that this component is of type "text".

        // In the component constructor we test if the component is of type "text", and use the fillText method instead of the fillRect method:

        myScore = new component("30px", "Consolas", "black", 280, 40, "text");//we can also use the long code that we learned in java 
        //text is the type of component 
        // (280,40) is coordinate of this component to be present 
        //Consolas means font of the text 
        //black is the color of the text 
        //30px is the size of the text 


        myGameArea.start(); //myGameArea is an object which is defined below and start is the prop0rty defined for this object and it contains a function hence () used with start

        //Change the Color
        //myGamePiece = new component(30, 30, "blue", 10, 120);
        //myGamePiece = new component(30, 30, "rgba(0, 0, 255, 0.5)", 10, 120);


        // myGamePiece = new component(140, 10, "red", 10, 120);//You can control the width and height of the component: by calling it again and removing above







        //             Add Some Obstacles
        // Now we want to add some obstacles to our game.

        // Add a new component to the gaming area. Make it green, 10px wide, 200px high, and place it 300px to the right and 120px down.

        // Also update the obstacle component in every frame:


        // myObstacle = new component(10, 200, "green", 300, 120);//Add a new component to the gaming area. Make it green, 10px wide, 200px high, and place it 300px to the right and 120px down.// (step 1 of adding obstacles) , later on we converted it into array









    }

    // The object myGameArea will have more properties and methods later in this tutorial.

    // The function startGame() invokes the method start() of the myGameArea object.

    // The start() method creates a <canvas> element and inserts it as the first childnode of the <body> element.

    var myGameArea = {
        canvas: document.createElement("canvas"),
        start: function () {
            this.canvas.width = 480;//default we set //this refers to myGameArea
            // this.canvas.width = 500 ;
            // this.canvas.width = 100 +"vw" ;//not works
            this.canvas.height = 270;

            this.context = this.canvas.getContext("2d");//as we always set

            document.body.insertBefore(this.canvas, document.body.childNodes[0]);








            //                 How to Use Images?
            // To add images on a canvas, the getContext("2d") object has built-in image properties and methods.

            // In our game, to create the gamepiece as an image, use the component constructor, but instead of referring to a color, you must refer to the url of the image. And you must tell the constructor that this component is of type "image":


            //now let's move to startGame()


























            //                 Multiple Obstacles

            // How about adding multiple obstacles?

            // For that we need a property for counting frames, and a method for execute something at a given frame rate. 



            this.frameNo = 0; //property for counting frames
            //frameNo is used for animation //it is a property we are defining in myGameArea and it is used in the function hence this. is used

            this.interval = setInterval(updateGameArea, 20);//In the myGameArea object, add an interval which will run the updateGameArea() function every 20th millisecond (50 times per second).

            //this.interval shows that interval is a property of myGameArea object and it is set to a function updateGameArea which is defined below and it is called every 20 milliseconds


            //updateGameArea will be called every 20 milliseconds 
            //20 is the time interval in milliseconds

            //setInterval is a function which is used to call a function (here updateGameArea) at a specified interval (here 20 sec)



            // Keyboard as Controller

            // Create a method that checks if a key is pressed, and set the key property of the myGameArea object to the key code. When the key is released, set the key property to false:




            //keyboard controller for myGamePiece turn also here




            window.addEventListener('keydown', function (e) {//keydown track not which key is being pressed 
                myGameArea.key = e.keyCode; //hence myGameArea.key property will track the keycode to check which key has been pressed

                //Then we can move the red square if one of the arrow keys are pressed:


                e.preventDefault();

                myGameArea.keys = (myGameArea.keys || []);//ya toh object property ya fir array
                myGameArea.keys[e.keyCode] = (e.type == "keydown");



            })

            window.addEventListener('keyup', function (e) {
                myGameArea.key = false; //it is even though affected , but not makes any change due to 20 times call


                myGameArea.keys[e.keyCode] = (e.type == "keydown");

                //here key will be e,keyCode and value is true or false


            })


            //ab aage ka turn keyboard se control karne ke liye updateGameArea() me code h





            // Multiple Keys Pressed

            // What if more than one key is pressed at the same time?

            // In the example above, the component can only move horizontally or vertically. Now we want the component to also move diagonally.

            // Create a keys array for the myGameArea object, and insert one element for each key that is pressed, and give it the value true , the value remains true untill the key is no longer pressed, the value becomes false in the keyup event listener function:




            window.addEventListener('keydown', function (e) {
                myGameArea.keys = (myGameArea.keys || []); //at start , myGameArea.keys will be empty string but there after it will be updated to it's initial value // myGameArea.keys = myGameArea.keys

                //Create a keys array for the myGameArea object,


                myGameArea.keys[e.keyCode] = true;//insert one element for each key that is pressed, and give it the value true

                //or 

                myGameArea.keys[e.keyCode] = (e.type == "keydown"); //e.type is keydown here because this is being passed as event 



            })


            window.addEventListener('keyup', function (e) {
                myGameArea.keys[e.keyCode] = false;//the value remains true untill the key is no longer pressed, the value becomes false in the keyup event listener function:

                //jo key up hoga ussi ko false karega

                //to see the effect properly , you can add speedX= 0 and  speedY= 0 for ecah step

                //or

                myGameArea.keys[e.keyCode] = (e.type == "keydown");  //it returns false as e.type is keyup as this event is being passed

            })





            // Using The Mouse Cursor as a Controller

            // If you want to control the red square by using the mouse cursor, add a method in myGameArea object that updates the x and y coordinates of the mouse cursor:.

            //NOTE: you should also hide the orignal cursor ,

            // this.canvas.style.cursor = "none"; //hide the original cursor

            //now we are again commenting it so that we can check blue button click


            window.addEventListener('mousemove', function (e) {
                myGameArea.x = e.pageX;//myGameArea utna khasak jaiga jitna usse pageX ko trigger karta, note yaha page bhi khaskega kyuki ye inbuilt event h  
                myGameArea.y = e.pageY;
            })








            //                 Touch The Screen to Control The Game
            // We can also control the red square on a touch screen.

            // Add a method in the myGameArea object that uses the x and y coordinates of where the screen is touched:




            window.addEventListener('touchmove', function (e) {
                myGameArea.x = e.touches[0].screenX; //I haven't studied this touchmove 
                myGameArea.y = e.touches[0].screenY;
            });

            // Then we can move the red square if the user touches the screen, by using the same code as we did for the mouse cursor:

            //  All below code is same just like mouse controller 










            //Controllers on The Canvas function to control buttons about which we talked above


            window.addEventListener('mousedown', function (e) {
                myGameArea.x = e.pageX;
                myGameArea.y = e.pageY;
            })
            window.addEventListener('mouseup', function (e) {
                myGameArea.x = false;
                myGameArea.y = false;
            })
            window.addEventListener('touchstart', function (e) {
                myGameArea.x = e.pageX;
                myGameArea.y = e.pageY;
            })
            window.addEventListener('touchend', function (e) {
                myGameArea.x = false;
                myGameArea.y = false;
            })


            // Now the myGameArea object has properties that tells us the x- and y-coordinates of a click. We use these properties to check if the click was performed on one of our blue buttons.

            // The new method is called clicked, it is a method of the component constructor, and it checks if the component is being clicked.  //check  click method in component

            //  In the updateGameArea function, we take the neccessarry actions if one of the blue buttons is clicked:
















        },

        clear: function () {//Also add a function called clear(), that clears the entire canvas.
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);//stop at it's position
            //it is necessary to stop again repainting
            // clearRect is used to clear the rectangle of the canvas 
            //0,0 is the top left corner of the canvas
            //this.canvas.width and this.canvas.height is the width and height of the canvas
        },   //clear is a property of myGameArea object and it is used in the function hence


        /* no use of below at this time but later we will uncomment it 
        stop : function() {
            clearInterval(this.interval);
            //clearInterval is a function which is used to stop the interval
            //this.interval is the interval which we set in the start function
            },



            draw : function() {
                this.context.fillStyle = "rgba(0, 0, 0, 0.5 )";
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                  }

                */




        //only adding obstacles make nothing happens when you hit the obstacle. In a game, that is not very satisfying.



        // How do we know if our red square hits the obstacle?

        // Create a new method in the component constructor, that checks if the component crashes with another component. This method should be called every time the frames updates, 50 times per second.

        // Also add a stop() method to the myGameArea object, which clears the 20 milliseconds interval.



        stop: function () {
            clearInterval(this.interval);
            //clearInterval is a function which is used to stop the interval
            //this.interval is the interval which we set in the start function
        },   //Also add a stop() method to the myGameArea object, which clears the 20 milliseconds interval.



    }




    // Add a Component

    // Make a component constructor, which lets you add components onto the gamearea.

    // The object constructor is called component, and we make our first component, called myGamePiece:

    //The components have properties and methods to control their appearances and movements.


    function component(width, height, color, x, y, type) {

        //In the component constructor we test if the component is of type "text", and use the fillText method instead of the fillRect method:

        this.type = type;//this refers to the current object which is being created and it will be like var objname = new component() and this will be refered to objname




        //In the component constructor we test if the component is of type "image", and create an image object by using the built-in "new Image()" object constructor.









        /*
        if (type == "image") {//it is only for mygamepiece , hence lower one is adviceable to use
            this.image = new Image();//Image constructor 
            this.image.src = color;//color ke position par hum src denge .
        }
            */


        //When we are ready to draw the image, we use the drawImage method instead of the fillRect method: //see in this.update section 




        //jo conditions se yaha initate hoga vo condition se drawImage update ke andar issi contion se hona chahiye , nahi toh unwanted results milenge
        if (type == "image" || type == "background") {//for both backgound image and gamePiece, image object will be created as background is also an object image hence it needs Image()
            this.image = new Image();
            this.image.src = color;

        }



        //agar sirf backound chahiya , alag se aur drw object alag se create karna h toh , image aur background ko alag alag initiate karo





        if (type == "image") {//it is only for mygamepiece , hence lower one is adviceable to use
            this.image = new Image();//Image constructor 
            this.image.src = color;//color ke position par hum src denge .


            //to set zIndex of a component in canva
            this.image.style.zIndex = 2;//3 is the value of zIndex ,


        } //issi conditions se drawing object banana chahiya update method me

        if (type == "background") {//it is only for mygamepiece , hence lower one is adviceable to use
            this.image = new Image();//Image constructor 
            this.image.src = color;//color ke position par hum src denge .

            //to adjust Opacity of image in canva
            this.image.style.opacity = 0.5;//0.5 is the value of opacity ,


            //to set zIndex of a component in canva
            // this.image.style.zIndex = 0;//1 is the value of zIndex ,




        }






        this.score = 0;//it is used to keep track of the score of the player
        //it is a property of the component object and it is used in the function hence this. is used


        //  this.gamearea = myGameArea; //not necessary for kyboard control

        this.width = width;
        this.height = height;







        //Game Rotation


        // Rotating Components
        // Earlier  the red square was able to move around on the gamearea, but it could not turn or rotate.

        // To rotate components, we have to change the way we draw components.

        // The only rotation method available for the canvas element will rotate the entire canvas:



        // Everything else you draw on the canvas will also be rotated, not only the specific component.

        // That is why we have to make some changes in the update() method:

        // First, we save the current canvas context object:

        // ctx.save();

        // Then we move the entire canvas to the center of the specific component, using the translate method:

        // ctx.translate(x, y);

        //Then we perform the wanted rotation using the rotate() method:

        // ctx.rotate(angle);

        // Now we are ready to draw the component onto the canvas, but now we will draw it with its center position of component at position 0,0 on the translated (and rotated) canvas: //for the rotated image , it 0,0 will be center of component not the corner of my gamearea

        // ctx.fillRect(width / -2, height / -2, width, height);


        // When we are finished, we must restore the context object back to its saved position, using the restore method:

        // ctx.restore();

        // The component is the only thing that is rotated:







        // The Component Constructor

        // The component constructor has a new property called angle, which is radian number that represents the angle of the component.

        this.angle = 0; //it's value is updated in updateGameArea

        // The update method of the component constructor is where we draw the component, and here you can see the changes that will allow the component to rotate:









        // Game Movement

        // With the new way of drawing components, done in the Game Rotation , the movements are more flexible. as we shift the position in its new shift translate after saving then restore




        // How to Move Objects?

        // Add a speed property to the component constructor, which represents the current speed of the component.

        this.speed = 1;

        // Also make some changes in the newPos() method, to calculate the position of the component, based on speed and angle.

        // The new position of the component is calculated using the following formula:
        // x = x + speed * cos(angle)
        // y = y + speed * sin(angle)

        //or 

        // this.x += this.speed * Math.sin(this.angle);
        // this.y -= this.speed * Math.cos(this.angle);


        // By default, the components are facing up, and by setting the speed property to 1, the component will start moving forward.








        // Making Turns

        // We also want to be able to make left and right turns. Make a new property called moveAngle, which indicates the current moving value, or rotation angle.

        this.moveAngle = 1;


        // In the newPos() method calculate the angle based on the moveAngle property:



















        //     Get in Control
        // Now we want to control the red square.

        // Add four buttons, up, down, left, and right.

        // Write a function for each button to move the component in the selected direction.

        // Make two new properties in the component constructor, and call them speedX and speedY. These properties are being used as speed indicators.


        this.speedX = 0;//speed of the component in x and y direction , 0 at start
        this.speedY = 0;//speed of the component in x and y direction

        this.x = x;//initial coordinate
        this.y = y;








        // Game Gravity

        // Some games have forces that pulls the game component in one direction, like gravity pulls objects to the ground.


        // To add this functionality to our component constructor, first add a gravity property(set with  this.gravity = 0; where this refers to component object which called it // here in component and myGamePiece.gravity= 0.05 ; in startGame so that only myGamePiece gets affected by gravity), which sets the current gravity. Then add a gravitySpeed property, which increases everytime we update the frame:




        this.gravity = 0;//The basic idea of gravity in JavaScript is that the object moves down the y axis constantly. So, create a function that moves the object in this way.//gravity is used to make the component fall down // gravity is predifined property 
        //we can define it as a property of the component object

        //it's illogical kyuki we have later on it's only affectedt the value of myGamePiece with gravity, bakiyo ka value set karne se kuchh nahi hota , gravity ka effect bhi implement karna padta h ...



        this.gravity = 0.05; //ye declare karne ka koi faida nahi h kyuki hum only for myGamePiece par hi gravity ka effect dikhate h toh isse koi dikat , nahi hone wali chahe toh myGamePiece.gravity = 0.05; ko hata sakte h startGame() se



        //it is a property of the component object and it is used in the function 
        this.gravitySpeed = 0;//it is user defined property and gravitySpeed property increases everytime we update the frame:

        //it will be updated in newPos







        // Bouncing

        // Another functionallity we want to add is the bounce property.

        // The bounce property indicates if the component will bounce back when gravity makes it fall down to the ground.

        // The bounce property value must be a number. 0 is no bounce at all, and 1 will make the component bounce all the way back to where it start falling.



        this.bounce = 0.6; //initiating property in component function method

        //bounce ke sat gravity 0.1 better hota h 


        this.gravity = 0.1;

        //but ye sirf hitBottom function me hi use hoga , so legin update newPos me bhi hoga , so what should we do, I have no idea 
        //if we keep the gravity=0.05 then bounce will be very small


        /*
        if( this.y > this.gamearea.canvas.height - this.height ){ //if it hits the ground then 
        this.gravity = 0.1; //this will make the bounce bigger
        }
        
        */
        //above code condition gives error because this.gamearea.canvas.height is not defined for component 













        this.update = function () { //only for difernet designing of component //In the component constructor, add a function called update(), to handle the drawing of the component.

            //here this.update = myGamePiece.update() after assigning in the newGame  
            ctx = myGameArea.context;



            //this position not suitable as it rotates all component

            /*
                            ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = color;
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
                ctx.restore();
            
            */













            // if the component is of type "text", and use the fillText method instead of the fillRect method:



            if (this.type == "text") {
                ctx.font = this.width + " " + this.height;
                ctx.fillStyle = color;
                ctx.fillText(this.text, this.x, this.y);


                //to set zIndex of a component in canva
                ctx.globalCompositeOperation = this.zIndex; //necessary for zIndex





            }







            if (this.type == "image") {

                // else if (this.type == "image") {//ye toh abhi update ka part h and vo bhi sirf mygamepiece ke liye , background ke liye nahi 

                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);

                //we are comenting this for now so that dublicate myPiece not created at the time of rotation

                //for now I am going to overlab the dublicate image without commenting it  but in main game , be careful with this



                //drawing tool toh hume image and background dono ke liye chahiye toh or use karna thik rahega 


                //ye image


                //agar image hoga toh background nahi issliye ek bar only if use kar ke dekh har jagah aur ; se end karna h , bas color fill karne ko else me dal dena 

            }

            //also working


            /*
            
            else if (type == "image") {//ye toh abhi update ka part h 
            
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            
            }
            
            */    /////works




            //kuch ho ya na ho , image and background agar sath me uppar component me object banaya h toh update me bhi sath me drawimage hona chahiye
            if (this.type == "image" || type == "background") { //ab image or background me se kuchh bhi ho drawImage will be activated

                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                //we are comenting this for now so that dublicate myPiece not created at the time of rotation but this will also not let the background to be applied , hence you can comment this if block and also it's declaration at top where you activated image and background toghether 

                //for now I am going to overlab the dublicate image without commenting it  but in main game , be careful with this




            }  //it is necessary for continous loop





            if (this.type == "image") {
                // else if (this.type == "image") { //ab image or background me se kuchh bhi ho drawImage will be activated

                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                //we are comenting this for now so that dublicate myPiece not created at the time of rotation
                //
                //for now I am going to overlab the dublicate image without commenting it  but in main game , be careful with this




                //to set zIndex of a component in canva
                ctx.globalCompositeOperation = this.zIndex; //necessary for zIndex





            }





            if (type == "background") {
                // else if (type == "background") {//agar ye else if me raha toh pahle wala toh pahle hi execute go gaya h , issliya ye execute nahi ho payega , agar execute karna h vo bhi else if me , toh uppar se type == "background" hatana padega
                ctx.drawImage(this.image, this.x + this.width, this.y, this.width, this.height);

                //to adjust Opacity of image in canva
                // ctx.globalAlpha = this.opacity; //necessary for opacity
                ctx.globalAlpha = this.opacity; //necessary for opacity


                //to set zIndex of a component in canva
                // ctx.globalCompositeOperation = this.zIndex; //necessary for zIndex
                ctx.globalCompositeOperation = 0; //necessary for zIndex








            }






            //type and this.type are seme , anything can be used in condition
            //jab sab kuchh chahiye to isko bhi image hi chahiye toh else me rahne ka koi faida nahi , ya toh fir esse if if conditon me rak do ya uppar elseif lagao, 

            //this else part is creating problem for myGamePiece , as once we used the color , now it's time to either comment that or replace else with if 

            if (this == myObstacles[i] || this == myUpBtn || this == myDownBtn || this == myLeftBtn || this == myRightBtn) {
                // else {
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);//(x,y) is coordinate 
                //it will be called every time in setinterval as setinterval call updateGameArea and  updateGameArea calls  myGameArea.clear();myGamePiece.newPos(); myGamePiece.update(); hence update value will be set here because of this , ctx.fillReact will be responssible for repainting the myGamePiece everytime after taking value from  this.newPos



            };





















            // window.addEventListener('keyup', function (e) {
            //     myGameArea.key = false;
            // }) //it also naot make it to work 









            //click method to track button click is added here
            //The new method is called clicked, it is a method of the component constructor, and it checks if the component is being clicked.


            this.clicked = function () { //here this refers to variable using component //if blue component is there then it refers to blue compent height



                //here we are deciding the area on where it c=get clicked like blue square kaha se kaha faila h , mtlab jab click ya touch us particular area par jaiga to vo blue component ka function active hoga

                // suppose left blue button is click then what area decides that left button is clicked is defined here, As we set //myLeftBtn = new component(30, 30, "blue", 20, 40);//above then it means left button area contains four corner and their cordinate 1(x,y) , 2(x+30,y), 3(x,y+30) , 4(x+30,y+30) //here 30 is width of blue component 
                var myleft = this.x;//it refers to left edge of square in term of x distance 
                var myright = this.x + (this.width);//right edge x+30
                var mytop = this.y;//top edge
                var mybottom = this.y + (this.height);//bootom edge

                var clicked = true;//at start maan lo fir setinval ke run karne se pahle hi clicked ki value update karlo , issliye hamne click check jus iske niche rakha h

                if ((mybottom < myGameArea.y) || (mytop > myGameArea.y) || (myright < myGameArea.x) || (myleft > myGameArea.x)) {
                    //it means agar touch ya mouse iss area ke bahar h toh clicked ko false kar do nahi toh ye if condition false hoga aur clicked ki value true remain rahegi 
                    clicked = false;
                }
                return clicked;
            }
            //myGameArea.y is refered to current position of mouse or click , matlab agar ye click uss blue region se bahar h to uss region ka clicked false rahega



            //   In the updateGameArea function, we take the neccessarry actions if one of the blue buttons is clicked:








            //for rotation

            //now if we want only to rotate the myGamePiece then we have to put in if condition

            ctx.save(); //it can be either insside or outside the if , effect of both same , ye sare component ko hi translate kar deta h initial position store karne ke liye hi save method use hota h.


            if (this == myGamePiece) {//The component myGamePiece is the only thing that is rotated:

                //now it makes only myGamePiece to be rotated


                ctx.save();  //save the current canvas context object: // either here or above required


                //we want to translate the entire canva
                // ctx.translate(this.x, this.y);

                //ctx.translate(x, y); //Then we move the entire canvas to the center of the specific component, using the translate method:

                //(this.x, this.y) is left top corner of old unrotated muGamePiece

                //    ctx.rotate(this.angle);

                //perform the wanted rotation using the rotate() method:  //makes it rotate only and every thime
                //it makes new myGamePiece to rotate about this translated coordinate as center , means left top coordinate of old myGamePiece will be 0,0 for new myGamePiece

                //image ka coordinate kitna bhi kyu na change karo , rotate toh translated position ke about karega




                //   ctx.drawImage(this.image, this.width / -2, this.height / -2, this.width, this.height); //this.width / -2, this.height / -2 is (-15,-15) coordinate se left top hoha //this -15,-15 is center of this new figure

                // to draw the component onto the canvas, but now we will draw it with its center position at position 0,0 on the translated (and rotated) canvas: //-2 shows aadha kiya h aur usko negive side se coordinate start kiya h
                //not makes overlapping image




                //  ctx.drawImage(this.image, 0, 0, this.width, this.height);

                //0,0 is center of new figure which is left top corner of old figure, which coincides with initial center

                //    ctx.rotate(this.angle);//same effect as if above declared
                //makes overlapping images //ab ye 0,0 center ke about rotate karega 


                //    ctx.drawImage(this.image, this.width / 2, this.height / 2, this.width, this.height);  //it will made it to make a circle 


                //ctx.drawImage(this.image, this.width / -1, this.height / -1, this.width, this.height); //1 unit ka circlular path follow karega



                //Now after analysing all , the overlapped ball ready with rotation

                ctx.translate(this.x + this.width / 2, this.y + this.height / 2); //this.x+this.width /2  ==0 now for new myGamePiece
                ctx.rotate(this.angle);
                ctx.drawImage(this.image, this.width / -2, this.height / -2, this.width, this.height); //drawImage should be only one in the inner call , if it is also drawn outside then try to overlap this new on that






                // ctx.fillStyle = color;
                // ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);



                ctx.restore(); //When we are finished, we must restore the context object back to its saved position, using the restore method:


                // ab 0,0 wapas gameArea ke left top ko bola jayega 


            }
            // ctx.restore();

            //             ctx.save();
            // ctx.translate(this.x, this.y);
            // ctx.rotate(this.angle);
            // ctx.fillStyle = color;
            // ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
            // ctx.restore();


            //here blue buttons and myGamePiece and green obstacles all got affected and even black frame is created for background







        }




        //Add a function in the component constructor, called newPos(), which uses the speedX and speedY properties to change the component's position.

        this.newPos = function () {

            this.gravitySpeed += this.gravity;//gravity speed ko update karo fir usse y coordinate me adjust karo 

            //gravitySpeed property, which increases everytime we update the frame:

            //jaise jaise niche aayegi uski speed badhegi issliye hume hit bottm par falling forever ko stop karna padega

            //same hume tophit , lefthit , right hit stop karna chahiye

            //here only myGamepiece gets affected because it is only initiated with non zero and rest are initiated with 0 by this.gravity = 0; in component function


            this.x += this.speedX;//new cordinate of x for this component //it is responsible to update x value every time but every time it is adding this.speedX when no button is triggered but once any button will change it's value from zero then it will not stop by moving in that direction unless it is changed in it's dirction by another click but set value of x and y will only update by up , down ,left and right  


            //it's stop method is at last with clearmove() 

            this.y += this.speedY; //y sirf speedY se nahi badhta balki issme gravity speed bhi add karna padta h  //hit top me y = 0 st karenge aur speedX humne hare step me pahle hi 0 liya h toh top par effect show nahi ho paye ga to drop

            //this will make keycontrol , button to work better or smooth but there will be no accelerate 


            this.y += this.speedY + this.gravitySpeed; //it makes accelerate possible, now we are trying to handle accelerate after learning basic concepts  


            //try to handle accelerate later , so we are commenting this and uncommenting the normal without gravity  , hence we used only this.y += this.speedY; at this time



            //    window.addEventListener('keyup', function (e) {
            //         myGameArea.key = false;
            //     }) //it also make it not even to accelerate once 








            //this.x  me x ki value right side move karegi aur jaise hi background ka width khatam hogi right end se tab x ki value background ke width ke sath match hogi 

            // myBackground.speedX = -1; //ye humne updateGameArea me dal diya tha , esliye speedX decrease hoga toh vo left side move karega

            //this.x += this.speedX; 

            //NOTE:

            //ye pahle hi set kar chuke h aur jaise ki  speedX har call me -1 set h toh vah x ko pahle se decrease karega , iska matlab jo left side se andar ja chuka h vo 0 hoga aur jo crrently x h vo bikul left edge par hoga , par xjo h vo 0 se -width tak pahuchega , isska matla left edge jab bilkul game area ke left side se andar chala jayega tab gamearea ka left edge par background ka right edge hoga , tab x ko fir se zero kar do toh issse vo turant yahi image fir se end par jod dega , x starting me 0 hoga


            //this.width will be 656 as per the passed and canvas width is 480 which has nothing to take care about it




            //NOTE : useful for CSS continuos loop, animation , background change //all detailed explaination is above and below 


            if (this.type == "background") {
                if (this.x == -(this.width)) {  //-ve sign issliye use kiya h kyuki this.x left edge ko show karta h aur this.width right edga ko ,  
                    this.x = 0; //ye image fir se vaha se start hoga so sudden ki hame pata hi nahi chalega ki humne kuch add kiya h 
                }
            }  //taki background loop kare  //In the newPos() method, check if the x position of the component has reach the end of the image, if it has, set the x position of the component to 0:






            //                 The lines of code you provided are part of a conditional statement within a programming context, likely related to object movement in a graphical environment, such as a game or animation.

            // ### Breakdown of the Code

            // 1. **`this.x`**: This represents the x-coordinate of an object in a coordinate system. The `this` keyword indicates that the code is part of an object's method or property, meaning `x` is a property of that object.

            // 2. **`this.width`**: This represents the width of the object. Like `this.x`, it is also a property of the object. It generally defines how wide the object is when rendered on the screen.





            //NOTE:  Remember




            // 3. **`this.x == -(this.width)`**: This conditional expression checks if the current x-coordinate of the object is equal to the negative value of its width. This could be used to determine if the object has moved off the left edge of the screen or viewport. For example, if an object has a width of 100 pixels, this check would verify if the x-coordinate is at -100 pixels.

            // 4. **`this.x = 0;`**: If the condition is true (meaning the object has moved completely out of sight to the left), this line resets the x-coordinate back to 0. This effectively repositions the object to the starting point on the horizontal axis.










            // ### How It Works

            // - **Movement**: This code is often part of a movement loop wherein the object's position is updated regularly. When the object moves left (e.g., `this.x` decreases), it may eventually reach a point where its x-coordinate equals `-(this.width)`, meaning it has completely left the visible area of the screen.

            // - **Resetting Position**: Upon reaching this condition, the object's position is reset to 0, bringing it back into view on the left side of the screen.

            // ### Speed of Execution

            // - **Efficiency**: This operation is very efficient, as it involves a straightforward comparison and assignment. Modern programming languages execute these basic operations incredibly quickly, often in a matter of nanoseconds.

            // - **Game Loop**: In a typical game or animation loop, such checks occur multiple times per second (e.g., 60 times per second). The efficiency of these operations allows for smooth movement and quick state updates without noticeable lag.

            // Overall, this code snippet is a simple but effective way to handle the repositioning of objects out of the visible area, enabling continuous movement in a defined space.





            this.hitBottom();

            // Hit the Bottom
            // To prevent the red square from falling forever, stop the falling when it hits the bottom of the game area:

            //it is in newPos method funtion property



            this.hitTop();
            // Hit the Top
            // To prevent the red square from going up forever, stop the rising when it hits the top of the game area:


            //condition to check if this is refering to myGamePiece then only it gets executed

            //without condition it would have stopped the background move also
            if (this === myGamePiece) {
                this.hitLeft();
            }

            // Hit the Left
            // To prevent the red square from moving left forever, stop the movement when it hits the left edge of the game area:


            if (this === myGamePiece) {
                this.hitRight();
            }

            // this.hitRight(); 
            // Hit the Right
            // To prevent the red square from moving right forever, stop the movement when it hits the right edge of the game area:














            //to make some changes in the newPos() method, to calculate the position of the component, based on speed and angle to Move Objects . 


            this.x += this.speed * Math.sin(this.angle);//angle we have set default 0 deg above in component function  , then x increment by 0  

            //lekin agar humne updateGameArea me myGamePiece ki value update kar di h toh yaha this.angle us update angle ko represent karega
            // myGamePiece.angle += 1 * Math.PI / 180;  //it is written in  updateGameArea

            //isse smooth ball forward movement show ho jata h as//this will make the ball(myGamePiece) to start moving forward(horizontally)

            //Note sign ki value pahle increase hogi then decrease hogi , issliye x direction me speed badegi , fir kuchh time ke liye stop hoga jab tak uski value 0 se kam rahegi fir kuchh der baad vo fir roll karega jab sin ki value greater than 0 hogi









            // this.y -= this.speed * Math.cos(this.angle);


            //y will be decrement by 1 in each repaints

            //yaha par y ko gravitySpeed , speedY , bounce and accelerate  bhi affect kar rahe h aur eske sath y decrement by 1 more every interval 

            //if we update the value of angle in updateGameArea 

            //// myGamePiece.angle += 1 * Math.PI / 180;

            //it's effect will be seen 
            //it will make y to start again after long time on the ground after increasing the angle cos value and effectively coping with gravitySpeed , speedY , bounce and accelerate 

            //this y is not good to start bouncing itself after long stop on the groung hence we are commenting here, but we will try this later on 







            //Note: if you want to change the value of speed and angle here directly , otherwise do it in updateGameArea

            //this.speed = 2; // speed of the object in pixels per frame
            //this.angle = Math.PI / 4; // angle of the object in radians





            this.angle += this.moveAngle * Math.PI / 180;

            //for making turns //it is just like updating the angle value above as per the above but there we updated angle in updateGameArea and now for making turn ,we are updating it here in this.newPos


            this.moveAngle = 0; // speed of the turn in degrees per frame







            //Final Conclusion , update the angle only once , either in this.newPos or updateGameArea only once ,it will be affected for all (rotation , moving , turn) 


            //if update angle is present more than once then all effects will be added and in this way , it will also make the ball to move backward along x




            //If angle is present only in my.newPos and y  and x is not affected by any gravitySpeed , speedY , bounce and accelerate  then it will make a complete outer circle like flying wheel


            //but if gravitySpeed , speedY , bounce and accelerate affecting the it will show exact performance as angle update in updateGameArea

            //if both active then only it moves backward at start but when only one is active then also it can move backward in air after updating all the values and this is happening all because of angle updating 

            //comment this angle if you want or assign only that sin/cos value which makes it move forward not backward , and for that x should be always positive

            //try to take sine value only from 0 to PI for updating angle and syntax for this is

            // this.angle = Math.sin(this.newPos.x * Math.PI / 180) * Math.PI //error

            // this.angle = Math.sin(this.newPos.x / 10) * Math.PI / 2 //error

            //Retry after revising maths concept






            //when gravitySpeed , speedY , bounce and accelerate are present






        }


        this.hitBottom = function () {
            var rockbottom = myGameArea.canvas.height - this.height;//height of gamearea- height of component , for here component is myGamePiece , this means rockbottom stores the maximum value of freespace available to move vertically downward from top
            if (this.y > rockbottom) { //agar newPos myGamePiece ka jaida hoga toh usse baar baar update kar rockbottom ke barrabar kar dena 
                this.y = rockbottom;

                //   this.gravitySpeed = 0;

                //bottom ko touch karne par gravitySpeed 0 ho jati h

                //bounce karne ke liye  this.gravitySpeed ki value decrement hogi

                this.gravitySpeed = -(this.gravitySpeed * this.bounce);

                //now it bounces properly , upper this.gravitySpeed = 0; must be commented



                //gravity speed ab negative direction me rahegi , bottom hit karne par , matab ab vo bounce hogi . 

            }
        }




        this.hitTop = function () {
            if (this.y < 0) { //agar newPos myGamePiece ka jaida h


                //   this.y = 0;//top ko touch karne par y 0 ho jati h //it makes it stick there

                this.y = 0; //chipka rahega kyuki , speedX bhi 0 h abd only gravity can impact this 

                //Now if we want to come back towards ground afetr heating the top then we sh0uld use this code
                //   this.gravitySpeed = -this.gravitySpeed; //this will make it bounce back towards ground

                if (this.y == 0) {
                    // this.gravitySpeed = -this.gravitySpeed;


                    //   this.gravitySpeed = -(this.gravitySpeed * this.bounce); 

                    //new position of y after heating the to , it will deaccelerate
                    //  this.y = this.y + this.gravitySpeed;
                    //    this.y = -(this.speedY - this.gravitySpeed);

                    // this.speedY=1;

                    //jo 0 tha usse initiate karenge toh ab vo automatically fall karaenge lekin ye bilul speedY + gravity dono feel karega , but we want oly to feel gravity





                    //NOTE: theses two lines speedY and gravitySpeed  are enough to set the smooth flow from top after striking

                    this.speedY = 0; //sabse pahle ye aur uppar nahi jane dega to top par strike karte hi ye aur aage badne ke capable nahi hoga  ye turant girega niche aur esliye bhi use karte h taki girte wakt esska value na badhe nahi to bottom hit karte wakt iski speed bahut jaida hogi aur ye wapas top par chala jayega 

                    //esse ye bhi faida h ki wapas aate wakt ye gravityspeed  sirf y ke position ko alter karega , speedY nahi 

                    // this.y += this.speedY + this.gravitySpeed; //responsible for changing the y position

                    this.gravitySpeed = 1; //gravitySpeed ko 1 karenge ,  ye gravityspeed fix kar dega taki isse baar baar update na karna pade , aur ye non-zero ban jayega
                    //    and gravity par dependend nahi rahega
                    // this.gravitySpeed += this.gravity; 



                    //aur nahi bounce par
                    // this.gravitySpeed = -(this.gravitySpeed * this.bounce);



                    //  this.gravity=0.05;//now it makes it work normally  //no need of this if gravitySpeed has been set to fixed value







                    //    this.y = 1;//ue niche le kar aayega but wapas bounce hokar top par chala jayega

                    //  this.y = this.speedY; //
                    //   this.gravitySpeed = this.gravitySpeed * this.friction; //this will make it deaccelerate and come back towards ground

                    // this.hitBottom();


                }


                // this.gravitySpeed = -(this.gravitySpeed * this.bounce); //this will make it
                //bounce back towards ground with some speed













                // this.y += 0.5 ; //not working


                //  this.gravitySpeed = 0;//top ko touch karne par gravitySpeed 0 ho jati h

                //   this.gravitySpeed = +(this.gravitySpeed); 

                //bahut der baad niche girega aur fir se bounce back ho jaiga

                //   this.y = +(this.gravitySpeed);

                //same as above

                //   this.y = +(this.gravity); //same effect as above


                //now to make this to fall back on ground due to gravity

                // this.gravitySpeed = 2;//gravitySpeed ko 2 se start kar dena
                // this.y = this.gravitySpeed; //not works 


                // this.gravitySpeed = +(this.gravitySpeed * this.bounce); 




                // this.accelerate




            }
        }



        this.hitLeft = function () {
            if (this.x < 0) { //agar newPos myGamePiece ka jaida h
                this.x = 0; //yaha this ke karan background image bhi move nahi karega , issleye component specify is better option in case of left and right hit stop and for that put the condition in newPos to class hitLeft only when this refers to myGamePiece






                // this.speedX = 0;

                //left ko touch karne par x 0 ho jati h //no need to specigy , it can work even without this //ye edges par usko rok dega , no reflection or accelerate or anything , hence 
            }
        }



        //and if myGamePiece can be assigned  GameStart then it would not have even given the required result

        //hence use condition to call hitLeft only for myGamePiece


        /*not suitably works downward code
                  myGamePiece.hitLeft = function () {
                      if (this.x < 0) { //agar newPos myGamePiece ka jaida h
                          this.x = 0; //yaha this ke karan background image bhi move nahi karega , issleye component specify is better option in case of left and right hit stop
      
      
      
                         // this.speedX = 0;//left ko touch karne par x 0 ho jati h 
                      }
                  }
      */



        this.hitRight = function () {
            if (this.x > myGameArea.canvas.width - this.width) { //agar newPos my
                this.x = myGameArea.canvas.width - this.width; //right ko touch karne par
                //  this.speedX = 0;//right ko touch karne par x 0 ho jati h
            }
        }




















        // Creating a new method in the component constructor, that checks if the component crashes with another component. This method should be called every time the frames updates, 50 times per second.
        //    hence we will add this in updateGameArea()//if (myGamePiece.crashWith(myObstacle)) {...


        this.crashWith = function (otherobj) {//when it is called then parameter otherobj is given with component object myObstacle
            //myGamePiece.crashWith(myObstacle)


            //below are all same as we did to identify myGamePiece position square edges

            var myleft = this.x;//left egde//this refers to object which is calling this component new //here "this" is for myGamePiece
            var myright = this.x + (this.width);//right edge of myGamePiece
            var mytop = this.y; //top edge og myGamePiece
            var mybottom = this.y + (this.height);//bottom edge og myGamePiece



            //hum obstacles ka edge value store karna chahte h  , it is done in the same way as per above 

            var otherleft = otherobj.x;//otherobj.x is myObstacle.x //left edge of obstacle
            var otherright = otherobj.x + (otherobj.width); //rightt edge of obstacle
            var othertop = otherobj.y; //top edge of obstacle
            var otherbottom = otherobj.y + (otherobj.height); //bottom edge of obstacle  



            var crash = true;//just like we initiated clicked and then put it into if , to get the cureent value of crash


            //if put the opposite colliding conditions as per requirement in if statement
            if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {//myleft > otherright means left edge of obstacle greater hona chahiye 
                crash = false; //matlab crash nahi hua h 
            }
            return crash;//ye value ab // if (myGamePiece.crashWith(myObstacle)) {myGameArea.stop();  } else {....} //see in updateGameArea() //  me crash ki value return hogi , agar true hua to stop call hoga 







        }


    }



    // Frames
    // To make the game ready for action, we will update the display 50 times per second, which is much like frames in a movie.

    // First, create a new function called updateGameArea().

    // In the myGameArea object, add an interval which will run the updateGameArea() function every 20th millisecond (50 times per second). Also add a function called clear(), that clears the entire canvas.

    // In the component constructor, add a function called update(), to handle the drawing of the component.

    // The updateGameArea() function calls the clear() and the update() method.

    // The result is that the component is drawn and cleared 50 times per second:





    function updateGameArea() {//The updateGameArea() function calls the clear() and the update() method.




        // var x, y; //at start then later more variables declared


        // Obstacles of Random Size

        // To make the game a bit more difficult, and fun, we will send in obstacles of random sizes, so that the red square must move up and down to not crash.

        // isme y ki value random chahiye , x ki size same rahegi issliye we used height instead of y

        var x, height, gap, minHeight, maxHeight, minGap, maxGap;

        //myObstacles.length is array length 

        for (i = 0; i < myObstacles.length; i += 1) {//rhink i here the the obstacle array index
            if (myGamePiece.crashWith(myObstacles[i])) {


                // mySound.pause();//ye niche wale ko play nahi honedega kyuki hamne pause jaise kuch decide hi nahi kiya h //instead of this write

                mySound.sound.pause();//now it works

                mySound.stop(); //now it works according to the requirement function we defined above

                //add eventlistener to play only when game mouse is over the game area
                myGameArea.canvas.addEventListener("mousemove", function () {

                    mySoundCrash.play(); //works

                    mySoundAfter.play();//to play the sound after playing 


                }); //end of eventlistener


                myGameArea.stop();

                //  mySound.play();//ye stop ke method ko overwrite kar dega to fir isse iss block se bahar rakhe







                // we need to restart the game after 2 sec
                setTimeout(function () {
                    // myGameArea.start();
                    // mySoundAfter.play();
                    // mySoundCrash.stop();
                    // mySoundCrash.pause();
                    // mySoundCrash.currentTime = 0;//reset the sound to 0 sec so that it
                    // //plays from the start
                    // myGamePiece.reset();
                    // myObstacles.length = 0;//clear the array so that new obstacles can be created
                    //mySound.play();//this will play the sound after 2 sec




                    // simply reload the page
                    location.reload();









                }, 2000);

                return; // crash true h to return 0 ho jayega updateGameArea se 
            }
        }










        //instead of above , at (step 1 of adding obstacles) , we used 
        // myObstacle.update();//Also update the obstacle component in every frame: //repaint here is called frame

        //it creates only one component , hence we converted it into array for adding many obstacles

        /*//This method should be called every time the frames updates, 50 times per second. hence we put it here but later we put if in for loop for multiple obstacles as we have done3 above
        
        //(step 2) me hum iss crashWith method ko bar bar call karna chahte h
        
        if (myGamePiece.crashWith(myObstacle)) {
            myGameArea.stop(); //agar crash true h toh myGameArea ruk jayega
          } else {
            myGameArea.clear();
            myObstacle.update();
            myGamePiece.newPos();
            myGamePiece.update();
          }
        
          */



        myGameArea.clear();//clear is called//Why Clear The Game Area?
        // It might seem unnecessary to clear the game area at every update. However, if we leave out the clear() method, all movements of the component will leave a trail of where it was positioned in the last frame:



        //Then we can move the red square if one of the arrow keys are pressed:

        // myGamePiece.speedX = 0;

        //it is set to control the move which we last time did with clearmove() //if it is not set then it will move diagonal movement affecting both x ,y in one repaint //you can try by comment speedX and speedY


        // myGamePiece.speedY = 0;

        //due to this setting only keys will work not the up and down ,up down works but as this updateGameArea() will be called , it reset speedX and Y to 0 hence , even if button will be pressed , it moves only one unit and fall back due to gravity and on again calling of set interval , it will again be setted to 0 , hence comment it to run both button and keys



        myGamePiece.moveAngle = 0;
        // for controlling the turn with keyboard


        /*  
                  if (myGameArea.key && myGameArea.key == 37 ) {
                      myGamePiece.speedX = -1;
      
                  }
      */
        /* for controlling turns by keyboard
        if (myGameArea.keys && myGameArea.keys[37]) {myGamePiece.moveAngle = -1; }
         */


        //for controlling both
        if (myGameArea.key && myGameArea.key == 37 && myGameArea.keys && myGameArea.keys[37]) {
            myGamePiece.speedX = -1;

            myGamePiece.moveAngle = -1;


        }


        if (myGameArea.key && myGameArea.key == 39 && myGameArea.keys && myGameArea.keys[39]) {
            myGamePiece.speedX = 1;
            myGamePiece.moveAngle = 1;
        }

        if (myGameArea.key && myGameArea.key == 38 && myGameArea.keys && myGameArea.keys[38]) {
            myGamePiece.speedY = -1;
            myGamePiece.speed = 1;
        }//sara khel gravity kharab kar rahi h , 

        //myGameArea.key = true and myGameArea.key == 37 (Ascii code to detect which key is pressed)

        //here key is not smooth working vertically  because of gravity it get set ever time reduced to one unit and next time again it rises only one and in update position starts again with initial value ,it is just like jumping in fixed position  not like updating from its current position hence create +=

        //ek bar trigger hogaya to ye sirf jump hi karta rah jayega , gravity usko 0 set kar degi aur updatepos fir se 1 unit affect karega kyuki -1 ne usse initiate kar diya h

        // if (myGameArea.key && myGameArea.key == 38) {myGamePiece.speedY += -1; } 

        //it would have been called 20 times 
        //now it makes it jump for smooth functioning but it accelerates like high jump even if only once clicked and not stop because it is in directly in updateGameArea() and it we are not setting myGameArea.key false and updating ecah time hence initial value will be stored in it and it makes it only jump and then come again due to gravity hence it is also not right way fir yeh myGameArea.key will become false hence gravity starts working to bring it down 

        // my key up will set it false but as it has triggered the speedY to be non_zero then it will update the position

        //use onkeyup to stop but it effects will not be seen there also
        if (myGameArea.key && myGameArea.key == 40 && myGameArea.keys && myGameArea.keys[40]) {
            myGamePiece.speedY = 1;
            myGamePiece.speed = -1;
        }




        //   window.addEventListener('keyup', function (e) {
        //       myGameArea.key = false; //it is even though affected , but not makes any change due to 20 times call
        //     }) //andar hi rahega to event ka asar andar hi rok dega jssse ab vo 1 unit bhi accelerate nahi ho payega









        // In the updateGameArea function, we take the neccessarry actions if one of the blue buttons is clicked:


        if (myGameArea.x && myGameArea.y) { //dono true ho matlab x aur y ki value not equal to zero ho , matlab , cursor mygamearea ke andar hona chahiya tabhi ye blue clicks kaaam karenge

            if (myUpBtn.clicked()) {//clicked value ussne component method se uthaya h 
                myGamePiece.y -= 1;//gamepiece ka position -1 se bar bar pahle ke position ke according y deduct hoga , matlab uppar jayega //ye touch screen h toh isse hun staring se repaint nahi karte , last set value ko hi aaye badhate h , pahle jaise ki hamne mouseup karte hi  myGameArea ko false kardiya tha , myGameArea.x = false; , jisse jab ye clicked me check karega toh false ho jaiga aur vahi ruk jaiga , toh agli bar click par vo wapas apne last position se aage badhe , but yaha apr ye effect dekhna h toh  esko , one click me ek hi bar chale esse set karo

                //agar hamne myGamePiece.y = 1 kiya hota to yeh clcik karne par uss coordinate par jump kar jata ya y = 1 par naki ek step uppar

                //ye initial se isseliye bhi start nahi karte kyuki isse speedX se koi lena dena nahi h jo change karna pade, speedX toh har call me 0 set hota h  , h toh x ki initial hi stored rahti  h again setinterval ke call karne par bhi 

                myGamePiece.y -= myGamePiece.gravitySpeed + myGamePiece.speedY;  //little good but need improvement

                // myGamePiece.y -=myGamePiece.gravitySpeed;  //little good but need improvement 

                // myGamePiece.y += myGamePiece.speedY;//dtupied

                // accelerate(-2);
                if (this.y <= 0) {
                    hitTop();
                }


            }
            if (myDownBtn.clicked()) {
                myGamePiece.y += 1;

                // accelerate(0.05);
            }
            if (myLeftBtn.clicked()) {
                myGamePiece.x += -1;
            }
            if (myRightBtn.clicked()) {
                myGamePiece.x += 1;
            }
        }

        myUpBtn.update();//this( myUpBtn) ko update method me sent kar diya //    ctx.fillRect(this.x, this.y, this.width, this.height); //bante h , initially jo h vahi h 
        //ye update sirf uss blue component ko dikhte rahne ke lye h , kyuki vo baar baar repaint hota  , agar nahi use kiya toh blue component gayab ho jayega par uss area ka effect abhi bhi hoga 
        //uss area ke blank par bhi click karke dekh sakte h , sab kaam karega

        myDownBtn.update();
        myLeftBtn.update();
        myRightBtn.update();

        myGamePiece.update();//ab game piece bhi toh update hoga //  ctx.fillRect(this.x, this.y, this.width, this.height);










        //iske pahle ka updateGameArea ke to par content h

        myGameArea.frameNo += 1;//ye value current se update hoti h

        if (myGameArea.frameNo == 1 || everyinterval(150)) {//at start par frameNo 1 h  //and jab ((myGameArea.frameNo / n) % 1 == 0) , true value return karega jab ye 0 ke barabar hoga //((myGameArea.frameNo / n) % 1 == 0) will be true for all frameno except 1

            //150 n is passed , 
            x = myGameArea.canvas.width;
            //  y = myGameArea.canvas.height - 200
            minHeight = 20;//for obstacle t size not position 
            maxHeight = 200;

            height = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight); //return rsndom height // Math.random() gives random no. between 0 and 1 // maxHeight - minHeight  =  (200-20=180) //maxHeight - minHeight + 1 = 181 //Math.random() * (maxHeight - minHeight + 1) is almost parts of 181, like 0.2 part or 0.5 or 0.8 any no. possible hence we add minheight to keep height atleast 20
            // Math.floor() function returns the largest integer less than or equal to a given number 

            minGap = 50;//these gaps we are deciding for top obstacles from lower obstcles which we created at first 
            maxGap = 200;

            gap = Math.floor(Math.random() * (maxGap - minGap + 1) + minGap); //same way of logic we used above for bottom random height //maxGap - minGap + 1 = 200-50+1 = 151 , iska kuchh bhi part select hoga toh maximum value jo// Math.random() * (maxGap - minGap + 1) gives is 201 and min 50


            // x = myGameArea.canvas.width;
            // y = myGameArea.canvas.height - 200

            // myObstacles.push(new component(10, 200, "green", x, y)); 

            //eska matlab green obstacle game area ke bahar se banega , kyuki x ki value bilkul end tak h , means vo gamearea ke bahar se banega starting hone par . aur y coordinate gamearea ke height se 200 uppar hoga , matlab obstacle ka height 200 ke barabar h. 

            //used for all obstacle of same size    //200 is height and 10 is width , (x,y) is the cooordinate

            myObstacles.push(new component(10, height, "green", x, 0));//for bottom obstacles 


            myObstacles.push(new component(10, x - height - gap, "green", x, height + gap)); //for top obstacles










            // mySound.play(); 

            //it play even after it crashes 

            // Background Music

            // To add background music to your game, add a new sound object, and start playing when you start the game:

            //so put this syntex in startGame instead














        }



        ///In the updateGameArea function we must loop through every obstacle to see if there is a crash. If there is a crash, the updateGameArea function will stop, and no more drawing is done.
        //NOTE :
        // The updateGameArea function counts frames and adds an obstacle for every 150th frame.



        //                 The line `if ((myGameArea.frameNo / n) % 1 == 0)` is a conditional statement used in programming, likely in a JavaScript context related to a game loop. Let's break it down:

        // 1. **myGameArea.frameNo**: This represents the current frame number of the game. In a typical game loop, `frameNo` is incremented with each iteration, tracking how many frames have been rendered.

        // 2. **n**: This is a variable that represents a divisor. Its purpose is to determine how frequently an event should occur, relative to the game's frame rate. For example, if `n` is 60, it might indicate that an action should occur once every 60 frames.
        //frame rate me vo obstacles ke bich kitna gap hoga

        // 3. **myGameArea.frameNo / n**: This divides the current frame number (`frameNo`) by `n`. The result is a number that potentially indicates how many complete cycles of `n` frames have passed. For instance, if `frameNo` is 120 and `n` is 60, this operation would yield 2.
        //150 frames ek cycle complete karega

        // 4. **% 1**: The modulus operator `%` calculates the remainder of the division of the number by 1. Since dividing any integer by 1 results in a whole number with no remainder, this operation effectively checks if the result of `myGameArea.frameNo / n` is an integer. If it is an integer, then `myGameArea.frameNo / n` will have no remainder, meaning that `(myGameArea.frameNo / n) % 1` will equal 0.
        //means it return true

        // 5. **== 0**: This comparison checks if the outcome of the modulus operation is equal to 0. If it is, this means that `myGameArea.frameNo` is exactly divisible by `n`, indicating that `n` frames have passed without any remainder.

        // In summary, this line effectively checks if `n` frames have been completed in terms of `myGameArea.frameNo`. If true, the condition inside the `if` statement will execute, allowing you to trigger certain actions (new obstacle green component ko push karna ) at specific intervals based on the frame count. For example, it may be used to update game logic or render new graphics every `n` frames.
        //n frame yaha gap ke according maan sakti h ki naya component 150 ke multiple distance par banega






        //                 Moving Obstacle
        // The obstacle is of no danger when it is static, so we want it to move.

        // Change the property value of myObstacle.x at every updat

        // myObstacle.x += -1;

        //to movew it left ward //only this reguired for moving the obstacle if there were only one obstacle , but since we had created array hence for loop is used below





        //In the updateGameArea function we must loop through every obstacle to see if there is a crash. If there is a crash, the updateGameArea function will stop, and no more drawing is done.

        for (i = 0; i < myObstacles.length; i += 1) {

            myObstacles[i].x += -1;//this is for position of green obstacle not for size of obstacle , size vahi rahega , bas ab vo left side move karega kyuki x axis decrease ho raha h.

            myObstacles[i].update(); //

            //setting z index of obstacle
            myObstacles[i].zIndex = 3; //this is for drawing obstacle on top

            // i want this to be always on top of any other thing wheather background or anything

            // new component backgroung still comes on top of it
            // so we need to set z index of background to 2 so that background comes on top
            // of obstacle and obstacle comes on top of player




        }



        // In the updateGameArea function we must loop through every obstacle to see if there is a crash. If there is a crash, the updateGameArea function will stop, and no more drawing is done.







        //At last we add some code in the updateGameArea function that writes the score onto the canvas. We use the frameNo property to count the score:

        myScore.text = "SCORE: " + myGameArea.frameNo; //do obstacle ke gap ko paar karne par 150 score hoga

        //At first this code will be written in updateGameArea() , above codes are written after feeling the needs for it

        myScore.update();




        //To update the background in every frame:
        myBackground.newPos();
        myBackground.update();






        //Moving Background

        // Change the background component's speedX property to make the background move:

        myBackground.speedX = -1;
        //it will end effect until the the image length finishes




        //Background Loop

        // To make the same background loop forever, we must use a specific technique.

        // Start by telling the component constructor that this is a background by using type== "background".   The component constructor will then add the image twice, placing the second image immediately after the first image.

        // In the newPos() method, check if the x position of the component has reach the end of the image, if it has, set the x position of the component to 0:






        ////to adjust Opacity of image in canva

        myBackground.opacity = 0.8;
        // myBackground.opacity = 0.9;
        // we want background to be transparent
        // myBackground.opacity = 0.1;

        // setting filter on the background having greyscale less




        // myBackground.contrast = 1;



        // we need to set this background set as backward and any other layer lies always on top of it
        // myBackground.zIndex = 0;
        myBackground.zIndex = -1;
        // myBackground.zIndex = 1;












        myGamePiece.newPos();//  myGamePiece.x += 1;//Make it Move
        // To prove that the red square is being drawn 50 times per second, we will change the x position (horizontal) by one pixel every time we update the game area:

        //   myGamePiece.zIndex=3;






        //for mouse move control

        if (myGameArea.x && myGameArea.y) { //ye toh starting me hi true hoga to mouse se chipka rahega to button ka effect hone se pahle hi vo pura scroll ho jayega



            // myGamePiece.x = myGameArea.x;
            // myGamePiece.y = myGameArea.y;   


        } //now it make the mouse to work , as mouse move red component also moves //updating value in updateGameArea is neccesary for every controller
        //good but the background flow should also be fast 

        //For now we don't want m0use move hence i am commenting it




        myGamePiece.angle += 1 * Math.PI / 180;  //commenting for turn , just for understasnding 

        //1 * Math.PI / 180 = 1 degree 

        //and speed of ball is also used to affect the position of ball

        //it will be used in component update method for rotating the ball at it's center and 
        // updating the position of the ball based on the angle of rotation , the radius of the ball 


        // will rotate one degree every time the gamearea updates (50 times per second).

        // Note: The angle property must be a radian. You can convert degrees into radians by using the formula x * Math.PI / 180

















        myGamePiece.update();//update() method. is called to handle the drawing of the component.






    }

    //for  Multiple Obstacles we need a method  for execute something at a given frame rate. //as we had declared  this.frameNo = 0;   , it will be incremented somewhere

    function everyinterval(n) { //The everyinterval function returns true if the current framenumber corresponds with the given interval.
        /// if (myGameArea.frameNo == 1 || everyinterval(150)) , n=150
        if ((myGameArea.frameNo / n) % 1 == 0) { return true; }
        return false;//else part
    }








    //         Accelerate Up
    // In a game, when you have a force that pulls you down, you should have a method to force the component to accelerate up.



    // Trigger a function when someone clicks a button, and make the red square fly up in the air:



    function accelerate(n) {
        myGamePiece.gravity = n;
    } //it is in script dictly not in other fuctions


    //<button onmousedown="accelerate(-0.2)" onmouseup="accelerate(0.1)">ACCELERATE</button>

    //this function accelerate(n) is called by button



    function moveup() {

        myGamePiece.speedY -= 1;//it will run for every updates on click means once it sets speedY to be -1 then it will be stored in speedY then as updateGameArea() is running with setinterval it will track speedY value and this value will be passed to  myGameArea.clear(); myGamePiece.newPos(); myGamePiece.update(); and once speedY is no more zero then its value will keep updating x by adding this speedY and hence once initiated will not stop due to newPos .


        //now you have to set the limit that it does not overflow , it has not be set here but you have to try.




        // for image change on 
        myGamePiece.image.src = "wink-sweet-n-sassy.gif"; //works for called button controller



    }

    function movedown() {
        myGamePiece.speedY += 1;//same story as above will be here 

        // for image change on 
        myGamePiece.image.src = "wink-sweet-n-sassy.gif";  //works for called button controller
    }

    function moveleft() {
        myGamePiece.speedX -= 1;

        // for image change on 
        myGamePiece.image.src = "wink-sweet-n-sassy.gif";  //works for called button controller

    }

    function moveright() {
        myGamePiece.speedX += 1;

        // for image change on 
        myGamePiece.image.src = "wink-sweet-n-sassy.gif";  //works for called button controller
    }




    // Stop Moving

    // If you want, you can make the red square stop when you release a button.

    // Add a function that will set the speed indicators to 0.

    // To deal with both normal screens and touch screens, we will add code for both devices:
    // <button onmousedown="moveup()" onmouseup="clearmove()" ontouchstart="moveup()">UP</button> //here onmouseup clearmove is added










    //         Change Images
    // You can change the image whenever you like by changing the src property of the image object of your component.


    // If you want to change the smiley everytime it moves, change the image source when the user clicks a button, and back to normal when the button is not clicked:



    function move(dir) {
        myGamePiece.image.src = "wink-sweet-n-sassy.gif"; //move karte wakt ye image show ho
        if (dir == "up") { myGamePiece.speedY = -1; }
        if (dir == "down") { myGamePiece.speedY = 1; }
        if (dir == "left") { myGamePiece.speedX = -1; }
        if (dir == "right") { myGamePiece.speedX = 1; }
    }

    //call this function in button outside the script

    // <button onmousedown="move('up')" onmouseup="clearmove()" ontouchstart="move('up')">UP</button><br><br>
    //   <button onmousedown="move('left')" onmouseup="clearmove()" ontouchstart="move('left')">LEFT</button>
    //   <button onmousedown="move('right')" onmouseup="clearmove()" ontouchstart="move('right')">RIGHT</button><br><br>
    //   <button onmousedown="move('down')" onmouseup="clearmove()" ontouchstart="move('down')">DOWN</button>





    //or put  myGamePiece.image.src = "angry.gif"; in all initially defined moveup() , movedown(), moveleft(), moveright() 





    function clearmove() {

        myGamePiece.image.src = "emoji.gif";  //works for all controllers

        //   myGamePiece.speedX = 0; 

        //it will make it run only one step and fall back due to gravithy hence either comment this or gravity for smooth execution of buttons 


        //   myGamePiece.speedY = 0;


    }




    // Keyboard as Controller
    // We can also control the red square by using the arrow keys on the keyboard.

    // Create a method that checks if a key is pressed, and set the key property of the myGameArea object to the key code. When the key is released, set the key property to false:











    // How to Add Sounds?

    // Use the HTML5 <audio> element to add sound and music to your games.

    // In our examples, we create a new object constructor to handle sound objects:



    // window.addEventListener(
    //         "mousemove",
    //         function (event) {
    //             // Check if the mouse is within the game area
    //             if (event.clientX > 0 && event.clientX < canvas.width && event.clientY > 0
    //                 && event.clientY < canvas.height) {
    //                 // If the mouse is within the game area, play the sound
    //                 mySound.play();

    //                 mySound.sound.pause();//now it works

    //             mySound.stop(); //now it works according to the requirement function we defined above

    //             mySoundCrash.play(); //works


    //             // myGameArea.stop();

    //             } else {
    //                 mySound.stop();
    //             }
    //         }
    //     );





    function sound(src) {
        this.sound = document.createElement("audio");
        this.sound.src = src;

        this.sound.setAttribute("preload", "auto");

        //set sound controller
        // this.sound.setAttribute("controls", "controls");

        //  this.sound.setAttribute("autoplay", "autoplay");
        this.sound.setAttribute("controls", "none");

        // this.sound.setAttribute("autoplay", "autoplay");


        this.sound.style.display = "none";

        //i want this to be small in size
        // this.sound.style.width = "100px";

        document.body.appendChild(this.sound);


        this.play = function () {
            this.sound.play();
        }
        this.stop = function () {
            this.sound.pause();//when you write mySound.pause() will not work but when we write mySound.stop() then it might work 
        }
    }




    //To create a new sound object use the sound constructor, and when the red square hits an obstacle, play the sound:



















</script>

</html>